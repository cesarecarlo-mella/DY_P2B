#-
#include all_header.h
#include process_header.h

#do i=1,&nproj&
l FF'i' =
#do j=1,&nproj&
+C('i','j')*T'j'
#enddo
;
#enddo
.sort

#include projectors/&proc&/proj_coeff.inc
.sort

#do i=1,&nproj&
#include tmp/layers/&layer&/ampl_recombined/FF'i'/S1.ff
#enddo

#opendictionary mth
#add pi_: "Pi"
#add i_: "I"
#add Z: "Zeta"
*#add d_: "Metric"
#closedictionary

id d_(i1?,i2?) = CMetric(i1,i2);
.sort

b CMetric,Tr, f, i_, gs,gem, eq, lambda, INT, T;
.sort

#do i=1,&nproj&
#if 'Nloop' > 0
#write <tmp/layers/&layer&/ampl_recombined/FF'i'/S1.ff> "id S1 = %e" FF'i';
#else

*#message rational simpl
b INT,Tr, f, Den,i_, gs, lambda, Num,s, Ratio,T,e_,d_,eq;
.sort
collect Num ;
.sort

id Num(n1?) = Ratio(n1,1);
id Den(n1?) = Ratio(1,n1);
.sort

*#message polyratfun
Polyratfun Ratio;
.sort
Polyratfun;
.sort
id Ratio(n1?,n2?) = Num(n1)*Den(n2);
.sort
factarg Num ;
factarg Den ;

chainout Num ;
chainout Den ;
.sort
repeat id Den(n1?number_) = 1/n1 ;
repeat id Den(n1?symbol_) = 1/n1 ;
repeat id Num(n1?number_) = n1 ;
repeat id Num(n1?symbol_) = n1 ;
.sort

#usedictionary mth
format mathematica;
#write <tmp/layers/&layer&/ampl_recombined/FF'i'/S1.ff> "%e" FF'i';
#endif
#enddo

.end
#+