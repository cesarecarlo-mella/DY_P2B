#-
#include all_header.h
#include ../../../process_header.h

&nproj& 


l expr = L'LAYER''SECTOR';
#message  Working on sector 'SECTOR' contribution to color layer 'LAYER'
#include ../../layers/'LAYER'/sector_separated/'FAMILY'/'SECTOR'.&nloop&.sect
.sort
*b Sector, i_, gs, lambda, eq, T, f, s, pol, Nc, Nf, NfZ, pol;
*#write <tmp/sector_separated_spinlines/'LAYER'/'SECTOR'_spinlines_out.2.dat> "id L'LAYER''SECTOR' = %e" expr;
*.sort
#message feynrules
#include feynman_rules.h
.sort
#if 'Nloop' > 0
#include ../../prop_substitutions/'FAMILY'.inc
.sort
#endif
id Prop(p1?) = Den(p1.p1);
.sort
argument Den;
#include ../../words_to_moms.inc
endargument;
.sort


*This should become a procedure to call 

#include invariants.h
argument Den;
#call subinvariants
endargument;


b Sector, i_, gs, lambda, eq, T, f, s, Nc, Nf, NfZ, Den,D1,...,D15,G;
.sort
#write <../../layers/'LAYER'/after_feynrules/'FAMILY'/'SECTOR'_feynrules_out.&nloop&.dat> "id L'LAYER''SECTOR' = %e" expr;


*this simplifies a little
#include pol_sum.h
#call gaugechoice&proc&
.sort

#do ii = 1, 'NPROJ'
g FF'ii' = proj'ii'*expr;
#include projectors/&proc&/proj.inc
.sort
#enddo

Drop;
NDrop FF1,...,FF'NPROJ';
.sort

id G(?x) = g_(?x);
.sort
#message tracing
tracen,1;
tracen,2;
tracen,3;
tracen,4;
contract;

.sort
#message polsum
#call polsum&proc&
.sort

#call onshell
antibracket Sector,C, T, f, i_, gs, lambda, eq, Den,&Ds&;
.sort
keep brackets;
#message  words2moms
#include ../../words_to_moms_alt.inc
.sort
#include ../../words2moms/words2moms_EXT.inc
.sort
#include ../../words2moms/words2moms_'FAMILY'.inc

b Sector,C, T, f, i_, gs, lambda, eq, Den,&Ds&,p1,p2,p3;
.sort 
keep brackets;
#message subinvariants
#call subinvariants
b Sector,C, T, f, i_, lambda, gs, eq, Den,&Ds&,k1,k2,k3;
.sort 
#message ISP
keep brackets;
#include ../../ISP/'FAMILY'.inc

.sort
id Sector(PL?,x?)/<D1^n1?>/.../<D&nprop&^n&nprop&?> = INT(PL,n1,...,n&nprop&);
.sort

#if 'Nloop' == 0
id INT(?x) = 1;
#else
#call reconstruction
#endif

b INT;
.sort 
keep brackets;
#message parsing zero integrals
#include ../../zeros/zeros'FAMILY'.inc
.sort
id INT('FAMILY',n1?,[],?x) = INT('FAMILY',?x);


b Sector, T,lambda,s, f, i_, d_, gs,eq,INT,C,Den,Num;
.sort
#message polyratfun
Collect Num;
id Num(n1?) = Ratio(n1,1);
id Den(n1?) = Ratio(1,n1);
.sort
Polyratfun Ratio;
.sort
Polyratfun;
.sort

id Ratio(n1?, n2?) = Num(n1) * Den(n2);

factarg Num;
factarg Den;

chainout Num;
chainout Den;
.sort
repeat id Den(n1?number_) = 1/n1;
repeat id Den(n1?symbol_) = 1/n1;
repeat id Num(n1?number_) = n1;
repeat id Num(n1?symbol_) = n1;
.sort

#opendictionary mth
#add pi_: "Pi"
#add i_: "I"
#add Z: "Zeta"
*#add d_: "Metric"
#closedictionary

#do ii = 1, 'NPROJ'
b Sector, T,lambda,gs,s, f, i_,INT,Num,Den,eq;
.sort
#if 'Nloop' > 0
#write <../../layers/'LAYER'/form_factors/FF'ii'/L'LAYER''SECTOR'.ff> "id L'LAYER''SECTOR' = %e" FF'ii';
#else
#write <../../layers/'LAYER'/ampl/FF'ii'/S1.ff> "id S1 = %e" FF'ii';
#endif
#enddo

*#usedictionary mth
*format mathematica;
*#write <../../layers/'LAYER'/form_factors/FF'ii'/L'LAYER''SECTOR'.ff> "%e" FF'ii';
#endif
#enddo



.end




